import Koa from 'koa';
import favicon from 'koa-favicon';
import secrets from './secrets';
import postgraphql from 'postgraphql';
import { extname, join } from 'path';
import staticMiddleware from 'koa-static';
import send from 'koa-sendfile';
import webpack from 'webpack';
import webpackConfig from '../../webpack.config.js';
import MemoryFileSystem from 'memory-fs';
import webpackMiddleware from 'koa-webpack';
import chalk from 'chalk';

const app = new Koa();

// If we don't serve our own favicon, the PostGraphQL middleware will
// serve the GraphQL logo on our behalf.
app.use(favicon(__dirname + '/favicon.ico'));

// Configure and mount PostGraphQL middleware
const pgConfig = { ...secrets.mnemosyne, max: 10 };
const schemas = ['public'];
const graphqlRoute = '/graphql';
const graphiqlRoute = '/graphiql';
app.use(postgraphql(pgConfig, schemas, {
  classicIds: false,
  dynamicJson: false,
  disableDefaultMutations: false,
  graphqlRoute,
  graphiqlRoute,
  graphiql: true,
  jwtSecret: undefined,
  jwtPgTypeIdentifier: undefined,
  pgDefaultRole: undefined,
  watchPg: undefined,
  showErrorStack: undefined,
  disableQueryLog: false,
  enableCors: false
}));

// The remaining routes are static assets built by webpack and should
// only respond to the HTTP verbs GET and HEAD.
app.use(async (ctx, next) => {
  if (ctx.method === 'GET' || ctx.method === 'HEAD') {
    await next();
  } else {
    ctx.status = ctx.method === 'OPTIONS' ? 200 : 405;
    ctx.set('Allow', 'GET, HEAD, OPTIONS');
  }
});

// Suss out the absolute path to the index file generated by HTML
// Webpack Plugin. We don't want to specify these paths separately in
// both webpack.config.js and in the server.
const index = join(
  webpackConfig.output.path,
  webpackConfig.plugins.filter(
    plugin => plugin.constructor.name === 'HtmlWebpackPlugin'
  ).pop().options.filename
);
if (process.env.NODE_ENV === 'production') {
  // Serve the static assets built by webpack
  app.use(staticMiddleware(webpackConfig.output.path));
  // Serve index.html on a wildcard route to facillitate client-side
  // routing. In real life we'd like this to be accompanied by an
  // appropriate HTTP status code.
  app.use(async ctx => await send(ctx, index));
} else {
  // same idea, but do it from webpack's in-memory filesystem.
  const compiler = webpack(webpackConfig);
  // webpack-dev-middleware and koa-webpack make it a breeze for files
  // in the manifest
  app.use(webpackMiddleware({ compiler }));
  // The wildcard route is trickier. We use a weird trick courtesy of
  // @jantimon to fish index.html out of memory.
  app.use(async ctx => {
    if (!(compiler.outputFileSystem instanceof MemoryFileSystem)) {
      const error = new Error(
        "The webpack compiler's output file system has not been" +
        'properly initialized by webpack-dev-middleware'
      );
      error.expose = true;
      throw error;
    }
    try {
      ctx.type = extname(index);
      ctx.body = compiler.outputFileSystem.readFileSync(index);
    } catch (error) {
      error.expose = true;
      throw error;
    }
  });
}

const port = 8080;
app.listen(port, () => {
  /* eslint-disable no-console */
  console.log('');
  console.log(
    `PostGraphQL server listening on port ${
      chalk.underline(port.toString())} ðŸš€`)
  console.log('');
  console.log(
    `  â€£ Connected to Postgres instance ${
      chalk.underline.blue(
        `postgres://${pgConfig.host}:${pgConfig.port}/${pgConfig.database}`
      )
    }`
  );
  console.log(
    `  â€£ Introspected Postgres schema(s) ${
      schemas.map(schema => chalk.magenta(schema)).join(', ')
    }`
  );
  console.log(
    `  â€£ GraphQL endpoint served at ${
      chalk.underline(`http://localhost:${port}${graphqlRoute}`)
    }`
  );
  console.log(
    `  â€£ GraphiQL endpoint served at ${
      chalk.underline(`http://localhost:${port}${graphiqlRoute}`)
    }`
  );
  console.log('');
  console.log(chalk.gray('* * *'));
  console.log('');
  /* eslint-enable no-console */
});
